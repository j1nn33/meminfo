#-------------------------------------
# одномерное динамическое программирование
"""
На числовой прямой сидит кузнечик, 
который может прыгать вправо на одну или на две единицы. 
Первоначально кузнечик находится в точке с координатой 1. 
Определите количество различных маршрутов кузнечика,
приводящих его в точку с координатой n.

Обозначим количество маршрутов кузнечика, 
ведущих в точку с координатой n, как K[n].
Прежде всего заметим, что существует ровно 
один маршрут из точки 1 в точку 1 — он не содержит 
ни одного прыжка. В точку 2 можно прыгнуть 
единственным способом — из точки 1.

рекурентная формула  Kn=Kn-2 + Kn-1

аналогичен алгоритму числа фибоначи
"""
def traj_num (N):
    K=[0, 1]+[0]*N
    for i in range (2, N+1):
        K[i]=K[i-2]+K[i-1]
    return K[N]

print (traj_num(4))

# добавим запрещенные точки allowed: list
# кузнечик может прыгать на 3 клетки
# рекурентная формула K[i]=K[i-1]+K[i-2]+K[i-3]
# allowed булевский массив запрещенных клеток
def count_trajectories (N, allowed: list):
    K = [0,1, int (allowed[2])]+[0]*(N-2)
    print ('init K', K) 
    for i in range(3, N):
        #print ('i',i)
        if allowed[i]:
            K[i]=K[i-1]+K[i-2]+K[i-3]

    print ('final K', K)
    return K[N-1]

ALLOWED_1 = [0,1,1,1,1,1]
ALLOWED_2 = [0,1,1,1,1,0]
print ('=========')
print (count_trajectories(5, ALLOWED_1))
print (count_trajectories(5, ALLOWED_2))

# минимальная стоимость достижения клетки N
# Стоимость прыжка в точку i - price[i] 
# C[i] — минимальная стоимость пути из 1 в i
# Выведем рекуррентное соотношение для этой функции.
# Чтобы попасть в точку n мы должны попасть в неё последним 
# прыжком из (n-1) или (n-2). Минимальные стоимости этих 
# маршрутов будут равны С[n-1] и С[n-2] соответственно, 
# к ним придется добавить значение price[n] за прыжок в 
# клетку n. Но из двух клеток мы можем выбрать любую.
# Нужно выбрать тот маршрут, который имеет наименьшую 
# стоимость: C[n] = min(C[n-1], C[n-2]) + price[n]

def count_min_cost (N, price:list):
    C = [None, price[1], price[1]+price[2]] + [0]*(N-2)  # 3
    for i in range(3, N+1):
        C[i]=price[i]+min(C[i-1], C[i-2])

    return C[N]

price = [None,1,2,2,1,4]
print ('++++++++')
print (count_min_cost(5, price))