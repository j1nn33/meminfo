# Сортировка слиянием 
# слияние отсортированных массивов A и В

def merge (A: list, B: list):
    C =[0]*(len(A)+len(B))  # создадим список С длиной А+В
    # i, k, n - индексы для А, В, С соответсвено
    i=k=n=0
    while i<len(A) and k<len(B):
        if A[i]<=B[k]:
            C[n]=A[i]
            i+=1
            n+=1
        else:
            C[n]=B[k]
            k+=1
            n+=1 
    # после того как один из массивов А или В закончился
    # заливаем к итоговому оставшийся и закончившийся массив (в нем не будет элементов)
    # чтобы не делать проверки какой из массивов закончился
    while i<len(A):
        C[n]=A[i]
        i+=1
        n+=1
    while k<len(B):
        C[n]=B[k]
        k+=1
        n+=1

    return C
""" тестированиая функции marge
A = [1, 3, 5]
B = [0, 1, 2, 4, 6, 7]
print (merge( A, B))
"""

# рекурсиваная функция сортировки слиянием (жрет память)
# Алгоритм рекурсивное слияние отсортированных массивов
def merge_sort(A):
    # проверка крайнего случая
    if len(A)<=1:
        return      # сортирует исходный массив
        # return A  # возвращает отсортированный массив (не исходный)
    middle = len(A)//2    # средний элемент
    L = [A[i] for i in range(0, middle)]     # левая часть массива
    R = [A[i] for i in range (middle, len(A))] # правая часть массива
    # опускаемся в рекурсию
    merge_sort(L)
    merge_sort(R)
    C = merge(L,R)
    # заполняем  А отсортированными элементами
    for i in range(len(A)):
        A[i] = C[i]

B = [5, 2, 7, 3, 1]
merge_sort(B)
print(*B)   

#-----------------------------------------
# Быстрая сортировка Тони Хоара
# выбираем барьерный элемент и сравниваем с ним остальные
# элементы и в зависимости от результата элемент помещается в
# ту или другую группу
def hoar_sort(A):
    # крайнии случаи
    if len(A)<=1:
        return
    # L - массив с элементами меньше барьерного
    # M - массив с элементами равными барьерному
    # R - массив с элементами больше барьерного
    barrier = A[0]
    L=[]
    M=[]
    R=[]
    for x in A:
        if x < barrier:
            L.append(x)
        elif x == barrier:
            M.append(x)
        else:
            R.append(x)
    
    hoar_sort(L)
    hoar_sort(R)

    # заливаем элементы в А обратно
    k=0
    for x in L+M+R:
        A[k]=x
        k+=1

B = [5, 2, 7, 3, 1]
hoar_sort(B)
print(*B)  


#------------
# проверка упорядоченности массива за O(len(A)) 
# алгорим отднопроходный
# отсортирован он или нет
# ascending = параметр как отсортирован массив 
# по возрастанию или по убыванию
def chech_sorted (A, ascending = True):
    flag = True
    x = int(ascending) # получение 0, 1 от False, True
    s = 2*x-1          # коэфициет для прохода по возрастанию или убыванию
    N = len(A)
    for i in range(0, N-1):
        if s*A [i]> s*A[i+1]:
            flag = False
            break
    return flag


A = [1, 2, 3, 5, 7]
B = [5, 2, 7, 3, 1]
C = [7, 4, 3, 2, 0]
print('по возрастанию', chech_sorted(A))
print('по убыванию   ', chech_sorted(A, False))
print('по возрастанию', chech_sorted(B))
print('по убыванию   ', chech_sorted(B, False))
print('по возрастанию', chech_sorted(C))
print('по убыванию   ', chech_sorted(C, False))

