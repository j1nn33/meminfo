# двумерные массивы

# Наибольшая общая подпоследовательность
# Подпоследовательность отличается от подстроки. 
# Например, если есть исходная последовательность "ABCDEF", то 
# "ACE" будет подпоследовательностью, но не подстрокой, а 
# "ABC" будет как подпоследовательностью, так и подстрокой."
# Так что когда на входные массивы [1, 2] и [1, 3, 2] алгоритм выдаёт ответ 2,
# подпоследовательность - это последовательность, полученная из исходной 
# путём удаления некоторых элементов, не обязательно идущих подряд.
"""
[1, 2, 3, 4, 5]
[1, 2, 4] - подпоследовательность
[1, 3, 5] - подпоследовательность
"""
# A, B - массивы чисел len(A) ==N  len(B) == M
# какая наибольшая подпоследоватеьность у них общая
# С содержит элементы А в исходном порядке , но возможно не все
# Fij - длина наибольшей возможной подпоследовательноси 
# частей А и В: А[0:i] - часть содежащая первые i элементов
#               В[0:j] - часть содежащая первые i элементов
# ------------------------
# ai=bj


def lcs (A,B):
    # len(A) +1 len(B) +1 чтобы включить 0 столбец = (крайний случай)
    F =[[0]*(len(B)+1) for i in range (len(A)+1)]
    
    for i in range (1, len(A)+1):
        for j in range (1, len(B)+1):
            # print (i,j)
            # идем по возрастанию
            if A[i-1] == B[j-1]:
                F[i][j] = 1 + F[i-1][j-1]
            else:
                F[i][j]=max(F[i-1][j], F[i][j-1])

    return  max (F[i]) #F[-1][-1]

A = [1, 2]
B = [1, 3, 2]

print (lcs(A,B))

# Наибольшая возрастающая подпоследовательность НВП
"""
Пример №1:
[1, 2, 3, 4, 5]
[1, 2, 4] - подпоследовательность
[1, 3, 5] - подпоследовательность
и т. д.
[1, 2, 3, 4, 5] - максимальная подпоследовательность
Пример №2:
[-1, 0, 1, 2, 0, 4, -3, -10, 5]
[-1, 0, 1, 2, 4, 5] - максимальная возрастающая подпоследовательность

Fi - НВП для части А [0:i], которая заканчивается 
и содержит элемент аi=A[i-1]

Fi= max(Fj)+1      |   [a1, a2,....,ai]
при этом: j<i      |   [a1,a2,..aj]
         ai>aJ     |

"""

def gis (A):
    F = [0]*(len(A)+1)
    for i in range (1, len(A)+1):
        m=0
        for j in range (1, i):
            if A[i-1]>A[j-1] and F[j]>m:
                m=F[j]
        F[i]=m+1
    
    return F[len(A)]

A= [-1, 0, 1, 2, 0, 4, -3, -10, 5]
print ('---------')
print (gis(A))