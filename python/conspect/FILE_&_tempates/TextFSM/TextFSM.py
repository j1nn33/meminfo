"""На оборудовании, которое не поддерживает какого-то программного интерфейса,
вывод команд show возвращается в виде строки.

TextFSM - это библиотека, созданная Google для обработки вывода с сетевых
устройств. Она позволяет создавать шаблоны, по которым будет обрабатываться
вывод команды.
"""
pip install textfsm

Для использования TextFSM надо создать шаблон, по которому будет обрабатываться
вывод команды.

Пример вывода команды traceroute:

r2#traceroute 90.0.0.9 source 33.0.0.2
traceroute 90.0.0.9 source 33.0.0.2
Type escape sequence to abort.
Tracing the route to 90.0.0.9
VRF info: (vrf in name/id, vrf out name/id)
1 10.0.12.1 1 msec 0 msec 0 msec
2 15.0.0.5 0 msec 5 msec 4 msec
3 57.0.0.7 4 msec 1 msec 4 msec
4 79.0.0.9 4 msec * 1 msec

Например, из вывода надо получить хопы, через которые прошел пакет.
=============================
файл traceroute.template:
=============================
Value ID (\d+)
Value Hop (\d+(\.\d+){3})
Start
^ ${ID} ${Hop} -> Record
=============================
Первые две строки определяют переменные:
Value ID (\d+) - эта строка определяет переменную ID, которая описывает регулярное выражение: 
    (\d+) - одна или более цифр сюда попадут номера хопов
    Value Hop (\d+(\.\d+){3}) - эта строка определяет переменную Hop, которая
                                описывает IP-адрес таким регулярным выражением: (\d+(\.\d+){3})

После строки Start начинается сам шаблон. В данном случае он очень простой:

^ ${ID} ${Hop} -> Record

сначала идет символ начала строки, затем два пробела и переменные ID и Hop
в TextFSM переменные описываются таким образом: ${имя переменной}
слово Record в конце означает, что строки, которые попадут под описанный
шаблон, будут обработаны и выведены в результаты TextFSM (с этим
подробнее мы разберемся в следующем разделе)


Скрипт для обработки вывода команды traceroute с помощью TextFSM
(parse_traceroute.py):
    
import textfsm
traceroute = '''
r2#traceroute 90.0.0.9 source 33.0.0.2
traceroute 90.0.0.9 source 33.0.0.2
Type escape sequence to abort.
Tracing the route to 90.0.0.9
VRF info: (vrf in name/id, vrf out name/id)
1 10.0.12.1 1 msec 0 msec 0 msec
2 15.0.0.5 0 msec 5 msec 4 msec
3 57.0.0.7 4 msec 1 msec 4 msec
4 79.0.0.9 4 msec * 1 msec
'''

template = open('traceroute.textfsm')  # содержимое файла с шаблоном TextFSM считывается в переменную template
fsm = textfsm.TextFSM(template)        # класс, который обрабатывает шаблон и создает из него объект в TextFSM    
result = fsm.ParseText(traceroute)     # метод, который обрабатывает переданный вывод согласно шаблону 
#                                       и возвращает список списков, в котором каждый элемент - это обработанная строка    

print(fsm.header)                      # я заголовок: print(fsm.header) , который содержит имена переменных и результат обработки
print(result)

Результат выполнения скрипта:
$ python parse_traceroute.py
['ID', 'Hop']
[['1', '10.0.12.1'], ['2', '15.0.0.5'], ['3', '57.0.0.7'], ['4', '79.0.0.9']]


Строки, которые совпали с описанным шаблоном, возвращаются в виде списка
списков. Каждый элемент - это список, который состоит из двух элементов: номера
хопа и IP-адреса.

Для работы с TextFSM нужны вывод команды и шаблон:
    для разных команд нужны разные шаблоны
    TextFSM возвращает результат обработки в табличном виде (в виде спискасписков)
    этот вывод легко преобразовать в csv формат или в список словарей
    
    
-------------------Синтаксис шаблонов TextFSM


Шаблон TextFSM описывает, каким образом данные должны обрабатываться.
Любой шаблон состоит из двух частей:
- определения переменных они описывают, какие столбцы будут в табличном представлении
- определения состояний

# Определение переменных:
Value ID (\d+)
Value Hop (\d+(\.\d+){3})
# Секция с определением состояний всегда должна начинаться с состояния Start
Start
# Переменные действие
^ ${ID} ${Hop} -> Record


    Определение переменных
- В секции с переменными должны идти только определения переменных.
- Единственное исключение - в этом разделе могут быть комментарии.
- В этом разделе не должно быть пустых строк. Для TextFSM пустая строка означает
  завершение секции определения переменных.
        Формат описания переменных:
Value [option[,option...]] name regex

Value - это ключевое слово, которое указывает, что создается переменная. Его обязательно нужно указывать

option - опции, которые определяют, как работать с переменной. Если нужно
указать несколько опций, они должны быть отделены запятой, без пробелов.

===============опции:

Filldown - значение, которое ранее совпало с регулярным выражением,
            запоминается до следующей обработки строки (если не было явно очищено
            или снова совпало регулярное выражение).
            это значит, что последнее значение столбца, которое совпало с
            регулярным выражением, запоминается и используется в следующих
            строках, если в них не присутствовал этот столбец.
Key      - определяет, что это поле содержит уникальный идентификатор строки
Required - строка, которая обрабатывается, будет записана только в том
            случае, если эта переменная присутствует.
List     - значение - это список, и каждое совпадение с регулярным выражением
            будет добавлять в список элемент. По умолчанию каждое следующее
            совпадение перезаписывает предыдущее.
Fillup   - работает как Filldown, но заполняет пустые значение выше до тех пор,
            пока не найдет совпадение. Не совместимо с Required.
name     - имя переменной, которое будет использоваться как имя колонки.
            Зарезервированные имена не должны использоваться как имя переменной.
regex    - регулярное выражение, которое описывает переменную. Регулярное
            выражение должно быть в скобках.
            
    Определение состояний
После определения переменных нужно описать состояния:

- каждое определение состояния должно быть отделено пустой строкой (как минимум, одной)
        первая строка - имя состояния
- затем идут строки, которые описывают правила
        правила должны начинаться с пробела и символа ^

Начальное состояние всегда Start. Входные данные сравниваются с текущим
состоянием, но в строке правила может быть указано, что нужно перейти к другому состоянию.
Проверка выполняется построчно, пока не будет достигнут EOF(конец файла), или
текущее состояние перейдет в состояние End

    Зарезервированные состояния
Зарезервированы такие состояния:
    
Start - это состояние обязательно должно быть указано. Без него шаблон не будет работать.
End - это состояние завершает обработку входящих строк и не выполняет состояние EOF.
EOF - это неявное состояние, которое выполняется всегда, когда обработка дошла
        до конца файла. Выглядит оно таким образом:
EOF
^.* -> Record

EOF записывает текущую строку, прежде чем обработка завершается. Если это
поведение нужно изменить, надо явно в конце шаблона написать EOF:

EOF

    Правила состояний
Каждое состояние состоит из одного или более правил:
TextFSM обрабатывает входящие строки и сравнивает их с правилами
если правило (регулярное выражение) совпадает со строкой, выполняются
действия, которые описаны в правиле, и для следующей строки процесс
повторяется заново, с начала состояния.

    Правила должны быть описаны в таком формате:
^regex [-> action]
    В правиле:
каждое правило должно начинаться с пробела и символа ^
символ ^ означает начало строки и всегда должен указываться явно
regex - это регулярное выражение, в котором могут использоваться переменные
для указания переменной,\ может использоваться синтаксис $ValueName или
    ${ValueName} (этот формат предпочтителен)
в правиле на место переменных подставляются регулярные выражения,
которые они описывают если нужно явно указать символ конца строки, используется значение $$
    Действия в правилах
    
    
После регулярного выражения в правиле могут указываться действия:
между регулярным выражением и действием должен быть символ ->
действия могут состоять из трех частей в таком формате: L.R S
    L - Line Action - действия, которые применяются к входящей строке
    R - Record Action - действия, которые применяются к собранным значениям
    S - State Action - переход в другое состояние
        если нет указанных действий, то по умолчанию используется действие
        Next.NoRecord.

Line Actions

Line Actions:

Next - обработать строку, прочитать следующую и начать проверять её с начала
        состояния. Это действие используется по умолчанию, если не указано другое
Continue - продолжить обработку правил, как будто совпадения не было, при этом
        значения присваиваются

Record Action

Record Action - опциональное действие, которое может быть указано после Line
                Action. Они должны быть разделены точкой. Типы действий:
NoRecord - не выполнять ничего. Это действие по умолчанию, когда другое не
                указано
Record - запомнить значения, которые совпали с правилом. Все переменные,
            кроме тех, где указана опция Filldown, обнуляются.
Clear - обнулить все переменные, кроме тех, где указана опция Filldown.
Clearall - обнулить все переменные.

Разделять действия точкой нужно только в том случае, если нужно указать и Line,
и Record действия. Если нужно указать только одно из них, точку ставить не нужно.
State Transition
После действия может быть указано новое состояние:
состояние должно быть одним из зарезервированных или определенных в шаблоне

если входная строка совпала:
        все действия выполняются,
        считывается следующая строка,
        затем текущее состояние меняется на новое, и обработка продолжается в
        новом состоянии.

Если в правиле используется действие , то в нем нельзя использовать переход в
другое состояние. Это правило нужно для того, чтобы в последовательности
состояний не было петель.

Error Action
Специальное действие Error останавливает всю обработку строк, отбрасывает все
строки, которые были собраны до сих пор, и возвращает исключение.
Синтаксис этого действия такой:

^regex -> Error [word|"string"]

=====================================================
   ===============ПРИМЕР==========================

имеется вывод 

15:10:44.867 UTC Sun Nov 13 2016

определим в шаблоне переменные:
    
в начале каждой строки должно быть ключевое слово Value
    каждая переменная определяет столбец в таблице
    следующее слово - название переменной
    после названия, в скобках - регулярное выражение, которое описывает значение
        переменной

Определение переменных выглядит так:
Value Time (..:..:..)
Value Timezone (\S+)
Value WeekDay (\w+)
Value Month (\w+)
Value MonthDay (\d+)
Value Year (\d+)
Подсказка по спецсимволам:
. - любой символ
+ - одно или более повторений предыдущего символа
\S - все символы, кроме whitespace
\w - любая буква или цифра
\d - любая цифра

После определения переменных должна идти пустая строка и состояние Start, а
после, начиная с пробела и символа ^ , идет правило (файл

templates/sh_clock.template):

Value Time (..:..:..)
Value Timezone (\S+)
Value WeekDay (\w+)
Value Month (\w+)
Value MonthDay (\d+)
Value Year (\d+)
Start
^${Time}.* ${Timezone} ${WeekDay} ${Month} ${MonthDay} ${Year} -> Record

    Так как в данном случае в выводе всего одна строка, можно не писать в шаблоне
    действие Record. Но лучше его использовать в ситуациях, когда надо записать
    значения, чтобы привыкать к этому синтаксису и не ошибиться, когда нужна
    обработка нескольких строк.

Когда TextFSM обрабатывает строки вывода, он подставляет вместо переменных их
значения. В итоге правило будет выглядеть так:

^(..:..:..).* (\S+) (\w+) (\w+) (\d+) (\d+)

1 группа: 15:10:44
2 группа: UTC
3 группа: Sun
4 группа: Nov
5 группа: 13
6 группа: 2016

В правиле, кроме явного действия Record, которое указывает, что запись надо
поместить в финальную таблицу, по умолчанию также используется правило Next. Оно
указывает, что надо перейти к следующей строке текста. Так как в выводе команды sh
clock только одна строка, обработка завершается.

Результат отработки скрипта будет таким:
$ python parse_output.py templates/sh_clock.template output/sh_clock.txt
Time Timezone WeekDay Month MonthDay Year
-------- ---------- --------- ------- ---------- ------
15:10:44 UTC        Sun       Nov     13         2016