
string1 = 'FastEthernet'
string1.upper()
# 'FASTETHERNET'
string1.lower()
# 'fastethernet'
string1.swapcase()
# 'fASTeTHERNET'
string2 = 'tunnel 0'
string2.capitalize()
# 'Tunnel 0'

# find()  поиск подстроки
string1 = 'interface FastEthernet0/1'
string1.find('Fast')
# 10
string1[string1.find('Fast')::]
# 'FastEthernet0/1'

                    startswith(), endswith()
# Проверка на то, начинается (или заканчивается) ли строка на определенные символы
# (методы startswith() , endswith() ):
string1 = 'FastEthernet0/1'
string1.startswith('Fast')
# True
string1.startswith('fast')
# False
string1.endswith('0/1')
# True
string1.endswith('0/2')
# False

                    replace()
# Замена последовательности символов в строке на другую последовательность
# (метод replace() ):
string1 = 'FastEthernet0/1'
string1.replace('Fast', 'Gigabit')
# 'GigabitEthernet0/1'

                    strip()
# Часто при обработке файла файл открывается построчно. Но в конце каждой строки,
# как правило, есть какие-то спецсимволы (а могут быть и в начале). Например, перевод
# строки.
# Для того, чтобы избавиться от них, очень удобно использовать метод strip() :
string1 = '\n\tinterface FastEthernet0/1\n'
print(string1)
#
# interface FastEthernet0/1
#
string1
# '\n\tinterface FastEthernet0/1\n'
string1.strip()
# 'interface FastEthernet0/1'
# По умолчанию, метод strip() убирает whitespace символы. Однако, ему можно передать
# как аргумент любые символы. Тогда в начале и в конце строки будут удалены все
# символы, которые были указаны в строке:
ad_metric = '[110/1045]'
ad_metric.strip('[]')
# '110/1045'
"""
Метод strip() убирает спецсимволы и в начале, и в конце строки. Если необходимо
убрать символы только слева или только справа, можно использовать, соответственно,
методы lstrip() и rstrip() .
"""

                split()
"""
Метод split() разбивает строку на части, используя как разделитель какой-то символ
(или символы). По умолчанию, в качестве разделителя используются пробелы. Но в
скобках можно указать любой разделитель.
В результате, строка будет разбита на части по указанному разделителю и
представлена в виде частей, которые содержатся в списке СПИСОК ВЫВОДИТЬСЯ в [ ]:
"""
string1 = ' switchport trunk allowed vlan 10,20,30,100-200\n'
commands = string1.strip().split()
print(commands)
# ['switchport', 'trunk', 'allowed', 'vlan', '10,20,30,100-200']
vlans = commands[-1].split(',')
print(vlans)
# ['10', '20', '30', '100-200']

"""
В строке string1 был символ пробела в начале и символ перевода строки в конце.
C помощью метода strip() эти символы удаляются.
Метод strip() возвращает строку, которая обрабатывается методом split() и
разделяет строку на части, используя пробел как разделитель. Итоговая строка
присваивается переменной commands.
Используя тот же способ, что и со строками, к последнему объекту в списке vlans
применяется метод split() . Но на этот раз внутри скобок указывается другой
разделитель - запятая. В итоге, в списке vlans находятся номера VLAN.
У метода split() есть ещё одна хорошая особенность: по умолчанию метод
разбивает строку не по одному пробелу, а по любому количеству пробелов. Это будет
очень полезным при обработке команд show.
"""
sh_ip_int_br = "FastEthernet0/0     15.0.15.1   YES manual up up"
sh_ip_int_br.split()
# ['FastEthernet0/0', '15.0.15.1', 'YES', 'manual', 'up', 'up']

# А вот так выглядит разделение той же строки, когда один пробел используется как
# разделитель:

sh_ip_int_br.split(' ')
"""
['FastEthernet0/0', '', '', '', '', '', '', '', '', '', '', '', '15.0.15.1', '', '', '
', '', '', '', 'YES', 'manual', 'up', '', 'up']
"""

#   Форматирование строк

"""
два варианта форматирования строк:
с оператором % (более старый вариант)
методом format() (новый вариант)

"""
#
# format
#
"""
Специальный символ {} указывает, что сюда подставится значение, которое
передается методу format. При этом, каждая пара фигурных скобок обозначает одно
место для подстановки.
"""

"interface FastEthernet0/{}".format('1')
# 'interface FastEthernet0/1'

"{2} , {1} , {0}".format('a', 'b', 'c')
#'c, b, a'
"""
можно вывести данные столбцами одинаковой ширины по
15 символов с выравниванием по правой стороне:
"""

vlan, mac, intf = ['100', 'aabb.cc80.7000', 'Gi0/1']
print("{:>15} {:>15} {:>15}".format(vlan, mac, intf))
#          100 aabb.cc80.7000         Gi0/1

#Выравнивание по левой стороне:
print("{:15} {:15} {:15}".format(vlan, mac, intf))
#100           aabb.cc80.7000 Gi0/1

#сколько цифр после запятой выводить:
print("{:.3f}".format(10.0/3))
#3.333

#Конвертировать в двоичный формат, указать, сколько цифр должно быть в
#отображении числа, и дополнить недостающее нулями:
'{:08b}'.format(10)
#'00001010'
#Аналогичный результат можно получить с помощью метода zfill:
bin(10)[2:].zfill(8)
#'00001010'

#
# Форматирование строк с оператором %
#
#  %s - строка или любой другой объект в котором есть строковое представление
#  %d - integer
#  %f - float

"interface FastEthernet0/%s" % '1'
#'interface FastEthernet0/1'


vlan, mac, intf = ['100', 'aabb.cc80.7000', 'Gi0/1']
print("%15s %15s %15s" % (vlan, mac, intf))
#          100 aabb.cc80.7000         Gi0/1
#Выравнивание по левой стороне:
print("%-15s %-15s %-15s" % (vlan, mac, intf))
#100           aabb.cc80.7000 Gi0/1

print("%.3f" % (10.0/3))
#3.333


"""
Объединение литералов строк
"""

s = ('Test' 'String')
s
#'TestString'
s = 'Test' 'String'
s
#'TestString'


s = ('Test'
     'String')
s
#'TestString'

regex = ('(\S+) +(\S+) +' #interface and IP
         '\w+ +\w+ +'
         '(up|down|administratively down) +' #Status
         '(\w+)') #Protocol


