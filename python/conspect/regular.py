Регулярные выражения
import re
match = re.search(regex, string)        # search в том, что она ищет только первое совпадение.
# У функции search два обязательных параметра:
regex     # - регулярное выражение
string    # - строка, в которой ищется совпадение
# Если совпадение было найдено, функция вернет специальный объект Match иначе None

match = re.search(pattern, string)   #  

re.match()     - ищет последовательность в начале строки
re.search()    - ищет первое совпадение с шаблоном
re.findall()   - ищет все совпадения с шаблоном. Выдает результирующие строки в виде списка
re.finditer()  - ищет все совпадения с шаблоном. Выдает итератор
re.compile()   - компилирует регулярное выражение. К этому объекту затем можно применять все перечисленные функции
re.fullmatch() - вся строка должна соответствовать описанному регулярному выражению 
              Кроме функций для поиска совпадений, в модуле есть такие функции:
re.sub      - для замены в строках
re.split    - для разделения строки на части

group()     - возвращает подстроку, которая совпала с выражением или с выражением в группе
groups()    - возвращает кортеж со строками, в котором элементы - это те
              подстроки, которые попали в соответствующие группы
              
groupdict() - возвращает словарь, в котором ключи - имена групп, 
 
start() и end() -  возвращают индексы начала и конца совпадения с регулярным
                   выражением значения -соответствующие строки
span()      - возвращает кортеж с индексом начала и конца подстроки.


Предопределенные наборы символов:
    
\d - любая цифра
\D - любой символ, кроме цифр
\s - whitespace ( \t\n\r\f\v )
\S - все, кроме whitespace
\w - любая буква или цифра
\W - все, кроме букв и цифр



log = '*Jul 7 06:15:18.695: %LINEPROTO-5-UPDOWN: Line protocol on Interface Ethernet0/3, changed state to down'
match = re.search('\d\d:\d\d:\d\d', log).group()      # group - удаляет тех. вывод 
print(match)
# '06:15:18'
# Выражение \d\d:\d\d:\d\d описывает 3 пары чисел, разделенных двоеточиями.

log2 = 'Jun 3 14:39:05.941: %SW_MATM-4-MACFLAP_NOTIF: Host f03a.b216.7ad7 in vlan 10 is flapping between port Gi0/5 and port Gi0/15'
match = re.search('\w\w\w\w\.\w\w\w\w\.\w\w\w\w', log2).group()
print(match)
# 'f03a.b216.7ad7'


##############################################################

Символы повторения:
    
regex*     - ноль или более повторений предшествующего элемента
regex+     - одно или более повторений предшествующего элемента
regex?     - ноль или одно повторение предшествующего элемента
regex{n}   - ровно n повторений предшествующего элемента
regex{n,m} - от n до m повторений предшествующего элемента
regex{n, } - n или более повторений предшествующего элемента

regular1 = re.search('\S{3}', regular).group()

line = '100 aab1.a1a1.a5d3 FastEthernet0/1'
re.search('a+', line).group()
'aa'
# А в этом выражении повторяется строка 'a1':
line = '100 aab1.a1a1.a5d3 FastEthernet0/1'
re.search('(a1)+', line).group()
# 'a1a1'

sh_ip_int_br = 'Ethernet0/1 192.168.200.1 YES NVRAM up up'
re.search('\d+\.\d+\.\d+\.\d+', sh_ip_int_br).group()
# '192.168.200.1'

line = '1500 aab1.a1a1.a5d3 FastEthernet0/1'
re.search('\d+\s+\S+', line).group()
# '1500 aab1.a1a1.a5d3'

#################################################

Специальные символы:
    
.       - любой символ, кроме символа новой строки
^       - начало строки
$       - конец строки
[abc]   - любой символ в скобках
[^abc]  - любой символ, кроме тех, что в скобках
a|b     - элемент a или b
(regex) - выражение рассматривается как один элемент. Кроме того, подстрока,которая совпала с выражением, запоминается
 
 
# специальные символы внутри квадратных
# скобок теряют свое специальное значение и обозначают просто символ. Например,
# точка внутри квадратных скобок будет обозначать точку, а не любой символ


##############################################################################
greedy   Пример жадного поведения:
import re
line = '<text line> some text>'
match = re.search('<.*>', line)
match.group()
#'<text line> some text>'

# То есть, в данном случае выражение захватило максимально возможный кусок символов, заключенный в <>.
# Если нужно отключить жадность, достаточно добавить знак вопроса после символов повторения:

line = '<text line> some text>'
match = re.search('<.*?>', line)
match.group()
#'<text line>

##########################################

Группировка выражений
 - Нумерованные группы
 - Именованные группы
 
#####################
Нумерованные группы

line = "FastEthernet0/1 10.0.12.1 YES manual up up"
match = re.search('(\S+)\s+([\w.]+)\s+.*', line)

# В данном примере указаны две группы:
# первая группа - любые символы, кроме whitespaces
# вторая группа - любая буква или цифра (символ \w ) или точка


# Теперь можно обращаться к группам по номеру. Группа 0 - это строка, которая соответствует всему шаблону:

print(match.group(0))  # Группа 0 - это строка, которая соответствует всему шаблону
# 'FastEthernet0/1 10.0.12.1 YES manual up up'
print(match.group(1))  # Группа 1 - любые символы, кроме whitespaces
# 'FastEthernet0/1'
print(match.group(2))  # Группа 2 - любая буква или цифра (символ \w ) или точка
# '10.0.12.1'

print(match.group(1, 2)) # или  match[1,2]
# ('FastEthernet0/1', '10.0.12.1')
print(match.group(2, 1, 2))
# ('10.0.12.1', 'FastEthernet0/1', '10.0.12.1')

################
Именованные группы

Именованные группы позволяют задавать группе имя.
Синтаксис именованной группы (?P<name>regex) :

line = "FastEthernet0/1 10.0.12.1 YES manual up up"
match = re.search('(?P<intf>\S+)\s+(?P<address>[\d.]+)\s+', line)
# Теперь к этим группам можно обращаться по имени:
print(match.group('intf'))
# 'FastEthernet0/1'
print(match.group('address'))
# '10.0.12.1'

#Также очень полезно то, что с помощью метода groupdict(), можно получить словарь,
#где ключи - имена групп, а значения - подстроки, которые им соответствуют:
match.groupdict()
{'address': '10.0.12.1', 'intf': 'FastEthernet0/1'}

# можно добавить группы в регулярное выражение и полагаться на их имя, а не на порядок:
match = re.search('(?P<intf>\S+)\s+(?P<address>[\d\.]+)\s+\w+\s+\w+\s+(?P<status>up|down|administratively down)\s+(?P<protocol>up|down)', line)
print(match.groupdict())
{'address': '10.0.12.1',
'intf': 'FastEthernet0/1',
'protocol': 'up',
'status': 'up'}

#########
Группа без захвата
По умолчанию все, что попало в группу, запоминается. Это называется группа с захватом

log = 'Jun 3 14:39:05.941: %SW_MATM-4-MACFLAP_NOTIF: Host f03a.b216.7ad7 in vlan 10 is flapping between port Gi0/5 and port Gi0/15'

# Регулярное выражение, которое описывает нужные подстроки:
match = re.search('(([0-9a-fA-F]{4}\.){2}[0-9a-fA-F]{4}).+vlan (\d+).+port (\S+).+port (\S+)', log)

#Выражение состоит из таких частей:
# [] - любой символ в скобках                    
# {} - число повторений предшествующего элемента  
# [0-9a-fA-F]{4}                      - f03a
# .  - любой симовол, кроме симовола новой строки
# [0-9a-fA-F]{4}\.                    - f03a.
# ([0-9a-fA-F]{4}\.){2}               - f03a.b216.
# ([0-9a-fA-F]{4}\.){2}[0-9a-fA-F]{4} - f03a.b216.7ad7

#.+vlan (\d+)                          - в группу попадет номер VLAN
#.+port (\S+)                          - первый интерфейс
#.+port (\S+)                          - второй интерфейс

#Метод groups вернет такой результат:
print=(match.groups())
#('f03a.b216.7ad7', 'b216.', '10', 'Gi0/5', 'Gi0/15')

# 'b216.' - второй элемент лишний он попал из -за ([0-9afA-F]{4}\.){2}
# нужно отключить захват в группе. Это делается добавлением ?: после открывающейся скобки группы.
match = re.search('(([0-9a-fA-F]{4}\.){2}[0-9a-fA-F]{4}).+vlan (\d+).+port (\S+).+port (\S+)', log)
match = re.search('((?:[0-9a-fA-F]{4}\.){2}[0-9a-fA-F]{4}).+vlan (\d+).+port (\S+).+port (\S+)', log)

print(match.groups())
# ('f03a.b216.7ad7', '10', 'Gi0/5', 'Gi0/15')

###########
Повторение захваченного результата
bgp = '''
R9# sh ip bgp | be Network
Network Next Hop Metric LocPrf Weight Path
* 192.168.66.0/24 192.168.79.7 0 500 500 500 i
*> 192.168.89.8 0 800 700 i
* 192.168.67.0/24 192.168.79.7 0 0 700 700 700 i
*> 192.168.89.8 0 800 700 i
* 192.168.88.0/24 192.168.79.7 0 700 700 700 i
*> 192.168.89.8 0 0 800 800 i
'''
#match = re.search(r'(\d+) \1', line)
# r - raw строка Тут удобней использовать ее, так как иначе надо будет 
# экранировать обратный слеш, чтобы ссылка на группу сработала корректно:
# match = re.search('(\d+) \\1', line)
#
#\1 подставляет результат, который попал в группу.
#Номер один указывает на конкретную группу. В данном случае это группа 1, она же единственная.
# те можно описать строки, в которых один и тот же номер встречается 2 раза:
for line in bgp.split('\n'):
    match = re.search(r'(\d+) \1 \1', line)
    #match = re.search(r'(\d+)\1 \1', line) # пробелы тоже важны  (другой результат)
    #print (match)
    if match:
        print(line)
        
#  192.168.66.0/24 192.168.79.7 0 500 500 500 i
#* 192.168.67.0/24 192.168.79.7 0 0 700 700 700 i
#* 192.168.88.0/24 192.168.79.7 0 700 700 700 i
#*> 192.168.89.8 0 0 800 800 i

#Аналогичным образом можно ссылаться на результат, который попал в именованную группу:
for line in bgp.split('\n'):
    match = re.search('(?P<as>\d+) (?P=as)', line)
    if match:
        print(line)







##########################################

# Пример

import re
int_line = ' MTU 1500 bytes, BW 10000 Kbit, DLY 1000 usec,'
match = re.search('MTU', int_line)
print(match)
# <_sre.SRE_Match object; span=(2, 5), match='MTU'>

match.group()
# 'MTU'
# Если совпадения не было, в переменной match будет значение None:
int_line = ' MTU 1500 bytes, BW 10000 Kbit, DLY 1000 usec,'
match = re.search('MU', int_line)
print(match)
# None

#  \d означает цифру, а + означает повторение предыдущего символа один или более раз. 

int_line = ' MTU 1500 bytes, BW 10000 Kbit, DLY 1000 usec,'
match = re.search('BW \d+', int_line)        # \d+ , получится выражение, которое означает одну или более цифр.
print(match.group() )
# 'BW 10000'

log2 = 'Oct 3 12:49:15.941: %SW_MATM-4-MACFLAP_NOTIF: Host f04d.a206.7fd6 in vlan 10 is flapping between port Gi0/5 and port Gi0/16'

re.search('Host (\S+) in vlan (\d+) is flapping between port (\S+) and port (\S+)', log2).groups()
# ('f03a.b216.7ad7', '10', 'Gi0/5', 'Gi0/15')

# Пример ь регулярное выражение, которое описывает email'ы двух форматов: user@example.com и user.test@example.com.
email1 = 'user1@gmail.com'
x = re.search('\w+@\w+\.\w+', email1).group()
print (x)
x = re.search('\w+@\w+\.\w+', email1)
print (x)
# 'user1@gmail.com'
#<_sre.SRE_Match object; span=(0, 15), match='user1@gmail.com'>
# Регулярное выражение для адреса с точкой: 
email2 = 'user2.test@gmail.com'
re.search('\w+\.\w+@\w+\.\w+', email2).group()

# Чтобы описать оба варианта адресов, надо указать, что точка в адресе опциональна:
# точка может появиться много раз.
\w+\.*\w+@\w+\.\w+
# ? Он обозначает ноль или одно повторение предыдущего выражения или символа. 
# Теперь регулярное выражение выглядит так 
\w+\.?\w+@\w+\.\w+


mail_log = ['Jun 18 14:10:35 client-ip=154.10.180.10 from=user1@gmail.com, size=551',
'Jun 18 14:11:05 client-ip=150.10.180.10 from=user2.test@gmail.com, size=768']
for message in mail_log:
    match = re.search('\w+\.?\w+@\w+\.\w+', message)
    if match:
        print("Found email: ", match.group())

# Found email: user1@gmail.com
# Found email: user2.test@gmail.com


